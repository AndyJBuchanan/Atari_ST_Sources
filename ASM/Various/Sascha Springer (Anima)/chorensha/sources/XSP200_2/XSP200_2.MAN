■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■
□　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　□
■　ｓｐｒｉｔｅ ５１２枚表示 ＆ ＰＣＧ定義管理 ｓｙｓｔｅｍ ’ＸＳＰ’ ■
□　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　□
■　ＶＥＲ．２．００ 第２改訂版 （ＶＥＲ．１．ｘｘとは一部非互換です）　■
□　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　□
■　　　　　　１９９７　９／１５　　　Ｂｙ　ファミベのよっしん　　　　　■
□　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　□
■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　こんな場合にお勧めです

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


「スプライトの０番が自機で、１番〜１５番が自機弾で、１６〜２３番が自機オプ

　ションで、２４〜１２７番が敵表示用で・・・、ボスが出てきたら、２４〜４７

　番をボス表示用、４８〜６３番をボスのレーザー用にして・・・、うお〜めんど

　くせ〜！！」

　というような場合。


「ＰＣＧの１６〜１２７番が敵表示用で、ボスが出てきたら６４〜１２７番をボス

　表示用に書き換えて・・・、おっと、ボスレーザーのＰＣＧも定義しなければ！

　うお〜めんどくせ〜！！」

　というような場合。


「ＳＨＡＲＰの sp_set関数はなんでこんなにトロいんじゃぁぁ！！」

　というような場合。


「最大１２８枚じゃ、雷電ＤＸもどきなんて作ませんってば！！」

　というような場合。


「Ｘ６８ＫのＰＣＧエリア、なんでこんなに狭いんじゃぁぁボケェ！！」

　というような場合。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　　ＸＳＰシステムの概要

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　ＸＳＰシステムはゲーム制作を想定した総合的なスプライト管理システムです。

機能一覧を以下に示します。


（１）スプライトを最大５１２枚（Ｘ６８Ｋの眼界の４倍！）表示することが可能

　　である。また画面中スプライト数が１２８以下の場合は、自動的にスプライト

　　表示数増加アルゴリズムをＯＦＦにすることで、ＣＰＵの負担を軽減。


（２）Ｘ６８Ｋの限られた少ないＰＣＧエリアに、それ以上（最大３２７６８）の

　　ＰＣＧを自動的に割当てて定義する。その結果ユーザーは、ＰＣＧエリアがあ

　　たかも最大３２７６８に拡張されたような環境が得られる。ＰＣＧ定義の際に

　　は、以下のような最適化を行う。

　 ・ すでに定義されているＰＣＧは重複定義しない。

　 ・ 新規定義用のＰＣＧエリアが不足した場合は、現在使用されていないＰＣＧ
　　　エリアを検索し、定義（上書き）する。

　 ・ 一度定義したＰＣＧは、後でまた必要になる可能性があるのでなるべく残す。


（３）従来の sp_set関数で必要であった、スプライトナンバーの割り当て作業が

　　不要になる。


（４）スプライト間表示優先度を６４段階（実質４８段階）に指定できる。


（５）複数のスプライトを結合させ、大きな１枚のスプライト（複合スプライト）

　　として表示することが可能である。（複合スプライトの形状データはユーザー

　　が作成する。）


（６）構造体を利用したパラメーター受け渡しが可能なスプライトＳＥＴ関数を実

　　装。Ｃ言語から実行する場合の、パラメーター受け渡し時のオーバーラップを

　　大幅に軽減できる。


（７）垂直同期を無視したでたらめなタイミングでのスプライト転送に対応。必要

　　に応じて同期を無視することにより、１ＶＳＹＮＣ先行処理などの通好みな処

　　理が可能である。


（８）ＸＳＰシステムと衝突することなく、ユーザー側でも垂直帰線期間割り込み

　　及びラスター割り込みを使用することが可能である（割り込み設定は、ＸＳＰ

　　システムが持つ専用関数にて行なうこと）。


（９）PCM8A.X（philly氏作）とＸＳＰシステムが完全同居できるように、PCM8A.X

　　側の割り込みマスクの設定を変更する関数が別途用意されている。


（１０）超快速である。



　実は欠点もあります。


（１）スプライトを１２９枚以上表示する時、分割ラスター上にてスプライト表示

　　優先度に破綻をきたすことがある（優先度破綻を軽減する機能も実装している

　　が、完全なものではない）。


（２）ＢＧ用・スプライト用兼用のＰＣＧの扱いが面倒である。


（３）表示画面サイズ２５６×２５６ドットモード以外には対応していない。


（４）実はシューティングゲーム向け。


（５）サイズがでかい。


（６）メモリを食う（約３４Ｋバイト）。


（７）Ｘ６８Ｋのスプライト関係の若干の知識が要求される。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　ＸＳＰシステムの簡単（？）な使用手順の説明

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　以下に、簡単な使用手順と補足次項を示します。詳しいことは「各関数の説明」

の項目を見て下さい。また、サンプルプログラムも用意されているので参考にして

下さい。


〜〜〜〜〜〜〜〜〜〜　以下、システム組込みと初期化　〜〜〜〜〜〜〜〜〜〜〜

手順１）・表示画面サイズ２５６×２５６ドットモードにする。

　　　　・スプライト表示をＯＮにする。

　　　　・xsp_on関数でＸＳＰシステムを組込む。


手順２）・xsp_pcgdat_set関数で、ＰＣＧデータとＰＣＧ配置管理テーブルを指定。

　　　　・必要なら、xsp_objdat_set関数で複合スプライト形状データを指定。

　　　　・必要なら、xsp_vertical関数で縦画面モードに変更。縦画面モードにす
　　　　　る場合は、付属の pcg_roll90関数を用いて、ＰＣＧデータ自体も縦画面
　　　　　対応に変換すること。


〜〜〜〜〜〜〜〜　以下、ゲームのメインループ中での処理　〜〜〜〜〜〜〜〜〜

手順３）・必要なら、xsp_vsync関数で垂直同期を取る。

手順４）・xsp_set関数、xobj_set関数等により、スプライトをシステム内バッファ
　　　　　に登録する。

手順５）・xsp_out関数で、システム内バッファに登録されたスプライトを一括表示
　　　　　する。


　　　　（手順３）に戻る。


〜〜〜〜〜〜〜〜〜〜　以下、プログラム終了時の処理　〜〜〜〜〜〜〜〜〜〜〜

手順６）・xsp_off関数で、ＸＳＰシステムを切り放す。


〜〜〜〜〜〜〜〜〜〜〜〜〜〜　その他、補足　〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜

補足１）・ＰＣＧデータ自体を（新たにロードする等して）変更した場合は、必ず
　　　　　再度、xsp_pcgdat_set関数により指定すること。

補足２）・必要なら、xsp_pcgmask_on/off関数で、ＸＳＰシステムに割り当てるＰ
　　　　　ＣＧエリアの確保・開放を行なう（xsp_on関数実行後なら常時可能）。

補足３）・必要なら、xsp_mode関数でスプライト表示数増加アルゴリズムを指定す
　　　　　る（xsp_on関数実行後なら常時可能）。

補足４）・必要なら、xsp_vsyncint_on／off関数で、垂直帰線期間割り込み処理の
　　　　　設定／解除を行なう（xsp_on関数実行後なら常時可能）。

補足５）・必要なら、xsp_hsyncint_on／off関数で、指定ラスターでの割り込み処
　　　　　理の設定／解除を行なう（xsp_on関数実行後なら常時可能）。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　　　　関数のコール方法

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　各関数はＣ言語のコール方式のみ対応となっています。アセンブラから使用する

場合は、Ｃ言語のコール方式に準拠して下さい。

　アセンブラからの使用するユーザーのために、Ｃ言語準拠コールの手順を説明し

ます。

手順１）　レジスタ d0-d2/a0-a2 をスタックに退避する。（仮に、コールする関数

　　　　内にて d0-d2/a0-a2 の総てが破壊されない場合でも、将来の拡張に備えて

　　　　d0-d2/a0-a2 の総てレジスタ保護を行なうこと。）


手順２）　引数を末端パラメーターから順にスタックに積む。その際、引数のデー

　　　　タの型に関係なくすべてロングワードサイズ（３２ビット）で積むこと。


手順３）　bsr または jsr 命令を用いて関数へサブルーチンジャンプする。その際

　　　　指定するラベルは、関数名の先頭にアンダーバーを付けて記述する。

　　　　　関数から戻ってきた時点の d0 の値は戻り値となっている。戻り値の型

　　　　は関数の型に対応している（例えば、short型の関数の戻り値では下位１６

　　　　ビットのみが有効な値となる）。


手順４）　手順２にてスタックポインタがズレているので、それを補正する。


手順５）　手順１で退避していたレジスタ d0-d2/a0-a2 の内容の復活を行なう。


　それではここで、アセンブラからのＣ言語準拠コールの例を示します。

	movem.l	d0-d2/a0-a2,-(sp)	* レジスタ退避
	move.l	#$013F,-(sp)		* INFO
	move.l	#0,-(sp)		* PT
	move.l	#200,-(sp)		* Y
	move.l	#100,-(sp)		* X
	jsr	_xsp_set		* 関数コール（アンダーバーを忘れず）
					* d0.w = 戻り値
	lea	4*4(sp),sp		* スタック補正（引数４つ分）
	movem.l	(sp)+,d0-d2/a0-a2	* レジスタ復活

この例では、xsp_set( 100 , 200 , 0 , 0x13F ); を実行したのと同じ意味合いと

なります。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　　　　各関数の説明

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


●　ｘｓｐ＿ｏｎ

　書式：void  xsp_on() ;

　戻り値：無し


　機能：ＸＳＰシステムの組込みと初期化を行います。初めに必ず実行するように

　　　して下さい。スプライト表示数増加処理のための割り込みの設定などは、本

　　　関数で行っています。すでに他で垂直及び水平同期割り込みが使用されてい

　　　ても、無視して実行します。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｏｆｆ

　書式：void  xsp_off() ;

　戻り値：無し


　機能：ＸＳＰシステムを切り放します。割り込みベクタなどは、すべてＸＳＰシ

　　　ステム組込み前の状態に戻されます。プログラム終了時に、必ず実行するよ

　　　うにして下さい。さもないと確実に暴走します。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｐｃｇｄａｔ＿ｓｅｔ

　書式：void  xsp_pcgdat_set( void *PCG_DAT ,char *PCG_ALT ,short ALT_SIZE );

　引数：void  *PCG_DAT：ＰＣＧデータへのポインター
　　　　char  *PCG_ALT：ＰＣＧ配置管理テーブルへのポインター
　　　　short ALT_SIZE：ＰＣＧ配置管理テーブルのサイズ（バイト数）

　戻り値：無し


　機能：ＰＣＧデータとＰＣＧ配置管理をテーブルを、ＸＳＰシステムに通達しま

　　　す。本関数は必ず実行して下さい。またＰＣＧデータ自体を（新たにロード

　　　する等して）変更した場合は、必ず本関数により各種データを再指定して下

　　　さい。

　　　　ＰＣＧ配置管理テーブルは、ＸＳＰシステムが内部で使用するためのデー

　　　タエリアです。用意したＰＣＧデータ枚数＋１バイトのサイズが必要です。
　　　　　　　　　　　　　　　　　　　　　　^^^^
　　　ＰＣＧ配置管理テーブルの初期化（０クリア）は本関数が自動的に行うので、

　　　ユーザーが行う必要はありません。

　　　　ＰＣＧデータのフォーマットは、いわゆるベタ形式です（そのフォーマッ

　　　トについては後述）。よって、スプライトツールＳＭ．Ｘ（Oh!X 1992年6月

　　　号付録）又は、ＥＥＬ．Ｘ（ＣＡＴｓｏｆｔ／ＧＯＲＲＹ氏作）でセーブし

　　　たＰＣＧデータ（拡張子.SP ）が、そのまま使えます。

　　　　なお、ＰＣＧデータは偶数アドレスから置かれていなければなりません。

　　　よって、アセンブラから使用する場合は偶数整合を必ず行って下さい。Ｃ言

　　　語から使用する場合は、初期値無しの char 型配列変数として宣言するか、

　　　short 型、又は int 型を使用して下さい（ＧＣＣでコンパイルする場合、初

　　　期値有りの char 型配列変数は、スイッチの有無に関係無く偶数整合が実行

　　　されないためです。（注）真里子版ＧＣＣ　ＶＥＲ１．２９で確認）。


　　　　それでは、ベタ形式ＰＣＧデータのフォーマットを説明します。１つのＰ

　　　ＣＧは４つの区画に分けられます。１つの区画は８×８ドットです。下図右

　　　示してあるのは１つの区画の拡大図です。

　　　　　　　　　　　　　　　　　　↑　┌───┬───┬───┬───┐
　　　　　　　　　　　　　　　　　　│　│＋００│＋０１│＋０２│＋０３│
　　　　　　　　　　　　　　　　　　│　├───┼───┼───┼───┤
　　　　　　　　　　　　　　　　　　│　│＋０４│＋０５│＋０６│＋０７│
　　　　　　　　　区画０拡大図　　　│　├───┼───┼───┼───┤
　　　　　　　　┌──────→　　│　│＋０８│＋０９│＋０Ａ│＋０Ｂ│
　　　　　　　　│　　　　　　　　　│　├───┼───┼───┼───┤
　　　　　　　　│　　　　　　　　　　　│＋０Ｃ│＋０Ｄ│＋０Ｅ│＋０Ｆ│
　　　　↑　┏━━━┳━━━┓　８ドット├───┼───┼───┼───┤
　　　　│　┃　　　┃　　　┃　　　　　│＋１０│＋１１│＋１２│＋１３│
　　　　│　┃区画０┃区画２┃　　　│　├───┼───┼───┼───┤
　　　　　　┃　　　┃　　　┃　　　│　│＋１４│＋１５│＋１６│＋１７│
　１６ドット┣━━━╋━━━┫　　　│　├───┼───┼───┼───┤
　　　　　　┃　　　┃　　　┃　　　│　│＋１８│＋１９│＋１Ａ│＋１Ｂ│
　　　　│　┃区画１┃区画３┃　　　│　├───┼───┼───┼───┤
　　　　│　┃　　　┃　　　┃　　　│　│＋１Ｃ│＋１Ｄ│＋１Ｅ│＋１Ｆ│
　　　　↓　┗━━━┻━━━┛　　　↓　└───┴───┴───┴───┘

　　　　　　←─１６ドット─→　　　　　←───── ８ ドット─────→

　　　図中の各数字は、データ先頭からのインデクス（バイト単位）を１６進数で

　　　表したものです。マス目１つで１バイトとなっており、各バイトの上位４ビッ

　　　トと下位４ビットが、連続した２ドットのカラーコード（１６色）を表して

　　　います。つまり１バイトあたり２ドットのデータ量なので、８×８ドットの

　　　区画あたり３２バイトのデータ量となります。区画１〜３も同様です。区画

　　　０〜３のデータを連結して１ＰＣＧ分のデータとします。合計１ＰＣＧあた

　　　り１２８バイトのデータ量となっています。

　　　　このようなデータを、パターンＮｏ．０から順に連続してメモリ上に配置

　　　してＰＣＧデータとします（下図）。

　　　　　+0x000┌────────┐
　　　　　　　　│　　　　　　　　│
　　　　　　　　│パターンＮｏ．０│
　　　　　　　　│　　　　　　　　│
　　　　　+0x080├────────┤
　　　　　　　　│　　　　　　　　│
　　　　　　　　│パターンＮｏ．１│
　　　　　　　　│　　　　　　　　│
　　　　　+0x100├────────┤
　　　　　　　　│　　　　　　　　│
　　　　　　　　│パターンＮｏ．２│
　　　　　　　　│　　　　　　　　│
　　　　　+0x180├────────┤
　　　　　　　　：　　　　　　　　：


--------------------------------------------------------------------------

●　ｘｓｐ＿ｐｃｇｍａｓｋ＿ｏｎ

　書式：void  xsp_pcgmask_on( short START_NO , short END_NO ) ;

　引数：short START_NO：マスク設定 開始ＰＣＧナンバー
　　　　short END_NO  ：マスク設定 終了ＰＣＧナンバー

　戻り値：無し


　機能：指定した範囲のＰＣＧエリアを、ＸＳＰシステムのＰＣＧ定義管理処理の

　　　対象外とするようにマスクします。本関数によりマスクされたＰＣＧエリア

　　　は、ＸＳＰシステムにより上書きされるなどして破壊されることがなくなり

　　　ます。

　　　　例えば既にユーザー側がＢＧスプライト用のＰＣＧ定義用として使用して

　　　いるＰＣＧエリアや、ＢＧ面に割り当てられたＰＣＧエリア（Ｎｏ．１２８

　　　〜２５５）がある場合は、そのエリアに上書きされては困るので、本関数に

　　　よりマスクする必要があります。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｐｃｇｍａｓｋ＿ｏｆｆ

　書式：void  xsp_pcgmask_off( short START_NO , short END_NO ) ;

　引数：short START_NO：マスク解除 開始ＰＣＧナンバー
　　　　short END_NO  ：マスク解除 終了ＰＣＧナンバー

　戻り値：無し


　機能：指定した範囲のＰＣＧエリアに設定されたマスクを解除します。マスクの

　　　詳細については、xsp_mask_on関数の説明を参照して下さい。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｍｏｄｅ

　書式：void  xsp_mode( short MODE_No ) ;

　引数：short MODE_No：１＝１２８枚ちらつかせ最大３８４枚モード
　　　　　　　　　　　 ２＝最大５１２枚モード（デフォルト）
　　　　　　　　　　　 ３＝最大５１２枚優先度破綻軽減モード

　戻り値：無し


　機能：スプライト表示数増加アルゴリズムを指定します。

　　　　１２８枚ちらつかせ最大３８４枚モードは、最大１２８枚のスプライトを

　　　ちらつかせることで、疑似的に１２８枚以上（最大３８４枚まで）表示する

　　　モードです。表示優先度の高いスプライトを優先的に表示するようにちらつ

　　　かせます。

　　　　最大５１２枚モードは、ラスター分割を利用した表示数増加アルゴリズム

　　　により、最大５１２枚のスプライトが表示可能なモードです。但し、アルゴ

　　　リズムの都合上、分割ラスター上にてスプライトの表示優先度が破綻するこ

　　　とがあります。

　　　　最大５１２枚優先度破綻軽減モードは、表示優先度の異なるスプライト間

　　　での優先度破綻を解消する最大５１２枚モードです。但し、スプライト表示

　　　数が極端に多い場合（目安は３００以上）や、極端に多くの異なる種類の優

　　　先度のスプライトを用いる場合、優先度破綻を解消しきれなくなることがあ

　　　ります。また、最大５１２枚モードに比べ、若干の処理負荷があります。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｏｂｊｄａｔ＿ｓｅｔ

　書式：void  xsp_objdat_set( void *SP_REF ) ;

　引数：void *SP_REF : 複合スプライトリファレンスデータへのポインター

　戻り値：無し


　機能：複合スプライトの形状データ（そのフォーマットについては後述）をＸＳ

　　　Ｐシステムに通達します。複合スプライトを使用する場合は、あらかじめ本

　　　関数を実行しておいて下さい。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｖｓｙｎｃ

　書式：short  xsp_vsync( short N );

　引数：short N：垂直帰線期間数

　戻り値：取り逃した垂直帰線期間数
　　　　　ＸＳＰシステムが組み込まれていなかったなら−１


　機能：N で示される垂直帰線期間数単位の垂直同期を行います。処理落ちが発生

　　　した場合は、次の垂直帰線期間まで待たないという（通好みな）仕様となっ

　　　ています。ゲームのメインループ中などに組み込んで下さい。

　　　　なお、１ＶＳＹＮＣ先行処理は、N に０を指定すると可能となります。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｓｅｔ

　書式：short  xsp_set( short X , short Y , short PT , short INFO ) ;

　引数：short  X  ：スプライトＸ座標
　　　　short  Y  ：スプライトＹ座標
　　　  short  PT ：スプライトＰＣＧパターンＮｏ．（0〜0x7FFF）
　　　  short INFO：反転コード・色・表示優先度を表わすデータ

　戻り値：そのスプライト座標（X,Y）が画面外だったなら０


　機能：スプライトの表示情報を、ＸＳＰシステムの内部バッファに登録します。

　　　xsp_out関数により、登録内容をもとにスプライトを一括表示できます。

　　　　INFO は、反転コード・色・表示優先度を表わすデータです。１６進数４桁

　　　で示され、各桁の内容は以下のようになっています。

　　　INFO＝０ｘ＊＊＊＊
　　　　　　　　↑↑↑↑
　　　　　　　　││││
　　　　　　　　││└┴───　表示優先度　（0〜0x3F）
　　　　　　　　││
　　　　　　　　│└─────　カラーコード（0〜0xF）
　　　　　　　　│
　　　　　　　　└──────　反転コード　　0x0：反転せず
　　　　　　　　　　　　　　　　　　　　　　　0x4：左右反転
　　　　　　　　　　　　　　　　　　　　　　　0x8：上下反転
　　　　　　　　　　　　　　　　　　　　　　　0xC：上下左右反転

　　　表示優先度の大きいスプライトほど、上に来るように表示されます。また、

　　　表示優先度を１６進数で表す場合の２桁目は、ＢＧとの優先度を表します。

　　　よって、

　　　　　表示優先度 0x30〜0x3F：ＢＧ０の上
　　　　　表示優先度 0x20〜0x2F：ＢＧ０・ＢＧ１の間
　　　　　表示優先度 0x10〜0x1F：ＢＧ１の下
　　　　　表示優先度 0x00〜0x0F：表示されない

　　　のようになります。



--------------------------------------------------------------------------

●　ｘｏｂｊ＿ｓｅｔ

　書式：void  xobj_set( short X , short Y , short PT , short INFO ) ;

　引数：short  X  ：複合スプライトのＸ座標
　　　　short  Y  ：複合スプライトのＹ座標
　　　  short  PT ：複合スプライトの形状パターンＮｏ．（0〜0x0FFF）
　　　  short INFO：反転コード・色・表示優先度を表わすデータ

　戻り値：無し


　機能：複合スプライトの表示情報をＸＳＰシステムの内部バッファに登録します。

　　　xsp_out関数により、登録内容をもとにスプライトを一括表示できます。

　　　　複合スプライトの形状データ（そのフォーマットについては後述）は、あ

　　　らかじめユーザーが用意しておき、xsp_objdat_set関数によりＸＳＰシステ

　　　ムに通達しておいて下さい。通達せずに本関数を実行した場合、動作の保証

　　　はありません。

　　　　なお、各引数の内容は xsp_set関数を参照して下さい。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｓｅｔ＿ｓｔ

　書式：short  xsp_set_st( void *STRUCT ) ;

　引数：void *STRUCT：パラメーター構造体へのポインター

　戻り値：そのスプライト座標が画面外だったなら０


　機能：構造体を通してパラメーターを受け渡す xsp_set関数です。xsp_set関数よ

　　　りも高速に実行できます。機能の詳細については、xsp_set関数を参照して下

　　　さい。

　　　　構造体のフォーマットは以下のようなものを用いて下さい。

　　　   ┌────── 先頭からのインデクス（バイト数）
　　　   │  ┌──── サイズ（ Ｗ：ワード ）
　　　   │  │    ┌─ 内容
　　　   ↓  ↓    ↓

　　　　＋０.Ｗ：スプライトＸ座標

　　　　＋２.Ｗ：スプライトＹ座標

　　　　＋４.Ｗ：スプライトＰＣＧパターンＮｏ．（0〜0x7FFF）

　　　　＋６.Ｗ：反転コード・色・表示優先度を表わすデータ（xsp_set関数の、
　　　　　　　　 引数 INFO に相当）


　　　　本関数を使用することを想定し、上記と同一の構造部分を持つ構造体上で

　　　のキャラクター管理を行うことを勧めます。



--------------------------------------------------------------------------

●　ｘｏｂｊ＿ｓｅｔ＿ｓｔ

　書式：void  xobj_set_st( void *STRUCT ) ;

　引数：void *STRUCT：パラメーター構造体へのポインター

　戻り値：無し


　機能：構造体を通してパラメーターを受け渡す xobj_set関数です。xobj_set関数

　　　よりも高速に実行できます。機能の詳細については、xobj_set関数を参照し

　　　て下さい。

　　　　構造体のフォーマットは以下のようなものを用いて下さい。

　　　   ┌────── 先頭からのインデクス（バイト数）
　　　   │  ┌──── サイズ（ Ｗ：ワード ）
　　　   │  │    ┌─ 内容
　　　   ↓  ↓    ↓

　　　　＋０.Ｗ：複合スプライトのＸ座標

　　　　＋２.Ｗ：複合スプライトのＹ座標

　　　　＋４.Ｗ：複合スプライトの形状パターンＮｏ．（0〜0x0FFF）

　　　　＋６.Ｗ：反転コード・色・表示優先度を表わすデータ（xsp_set関数の、
　　　　　　　　 引数 INFO に相当）


　　　　本関数を使用することを想定し、上記と同一の構造部分を持つ構造体上で

　　　のキャラクター管理を行うことを勧めます。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｏｕｔ

　書式：short  xsp_out() ;

　戻り値：システム内部バッファに登録された総スプライト数


　機能：xsp_set関数、xobj_set関数、xsp_set_st関数、xobj_set_st関数によって

　　　ＸＳＰシステムの内部バッファに登録されたスプライト表示情報をもとに、

　　　スプライトの一括表示を行います。

　　　　xsp_pcgdat_set関数によるＰＣＧデータ等の指定、xsp_objdat_set関数に

　　　よる複合スプライト形状データの指定等の初期化は、本関数実行前までに必

　　　ず済ませておいて下さい。必要な初期化をせず本関数を実行した場合、動作

　　　の保証はありません。

　　　　なお仕様上、本関数を１表示期間中に３回以上実行しようとすると、次の

　　　垂直帰線期間が来るまでウェイトがかかります。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｖｅｒｔｉｃａｌ

　書式：void  xsp_vertical( short flag ) ;

　引数：short flag：１のとき、縦画面モードＯＮ。
　　　　　　　　　　０のとき、縦画面モード０ＦＦ。

　戻り値：無し


　機能：ディスプレイを立てて使う縦画面モードの、ＯＮ／０ＦＦを指定します。

　　　ディスプレイを立てて使うことは、ディスプレイの健康上好ましくないこと

　　　ですから、十分に注意した上で各自の責任の上で取り扱って下さい。

　　　　縦画面モードでは、ディスプレイは左を下にして使用して下さい（６８版

　　　ドラスピと同じです）。ＰＣＧデータもそれに対応するように描き換えて、

　　　xsp_pcgdat_set関数で再度指定して下さい（ＰＣＧデータを９０度回転させ

　　　る関数も、別途用意しておきました）。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｖｓｙｎｃｉｎｔ＿ｏｎ

　書式：void  xsp_vsyncint_on( void *PROC ) ;

　引数：void *PROC：割り込み処理関数（またはサブルーチン）へのポインター

　戻り値：無し


　機能：ユーザー独自の帰線期間割り込み処理の設定をします。ここで指定された

　　　割り込み処理関数は、ＸＳＰシステム内から帰線期間割り込みと同時に実行

　　　されます。指定する割り込み処理関数は一般のＣ言語の関数で良く、ＧＣＣ

　　　の拡張機能により割り込み処理用に記述された関数である必要はありません。

　　　アセンブラで記述したサブルーチンを割り込み処理ルーチンとして指定する

　　　場合は、そのサブルーチンの終わりは rte命令でなく、rts命令として下さい。

　　　また、サブルーチンの前後でのレジスタ退避復帰は一切必要ありません。

　　　　なお、ユーザー指定の帰線期間割り込み処理は、なるべく処理負荷の軽い

　　　ものにして下さい。割り込み処理が長引き、表示期間に突入してもその処理

　　　が終了していないような場合、スプライト表示に支障を来すなどの弊害を生

　　　じます。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｖｓｙｎｃｉｎｔ＿ｏｆｆ

　書式：void  xsp_vsyncint_off() ;

　戻り値：無し


　機能：xsp_vsyncint_on関数により指定された、ユーザー独自の帰線期間割り込み

　　　処理を解除します。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｈｓｙｎｃｉｎｔ＿ｏｎ

　書式：void  xsp_hsyncint_on( void *TIME_CHART ) ;

　引数：void *TIME_CHART：ラスター割り込み処理タイムチャートへのポインター

　戻り値：無し


　機能：ユーザー独自のラスター割り込み処理を、タイムチャートにより設定しま

　　　す（タイムチャートのフォーマットについては後述）。タイムチャートの内

　　　容に基づき、ＸＳＰシステムは指定ラスターでの割り込み処理を発生します。

　　　　タイムチャートで指定する割り込み処理関数は、一般のＣ言語の関数で良

　　　く、ＧＣＣの拡張機能により割り込み処理用に記述された関数である必要は

　　　ありません。アセンブラで記述したサブルーチンを割り込み処理ルーチンと

　　　して指定する場合は、そのサブルーチンの終わりは rte命令でなく、rts命令

　　　として下さい。また、サブルーチン内で破壊しても良いレジスタは、d0-d2/

　　　a0-a2 です。それ以外のレジスタを扱う場合は、内容の退避復帰を必ず行なっ

　　　て下さい。

　　　　なお、ユーザー指定のラスター割り込み処理は、特に処理負荷の軽いもの

　　　にして下さい。割り込み処理が長引き、次のラスター割り込みが発生する時

　　　点に突入してもその処理が終了していないような場合、スプライト表示に支

　　　障を来すなどの弊害を生じます。


　　　　それではここで、タイムチャートのフォーマットについて説明します。タ

　　　イムチャートは、構造体の配列変数上に作成します。タイムチャート構造体

　　　１要素あたりのフォーマットは以下のようになっています。これを羅列した

　　　ものをタイムチャートとし、本関数にて指定して下さい。


　　　   ┌────── 先頭からのインデクス（バイト数）
　　　   │  ┌──── サイズ（ Ｗ：ワード　Ｌ：ロングワード ）
　　　   │  │    ┌─ 内容
　　　   ↓  ↓    ↓

　　　　＋０.Ｗ：割り込みラスターナンバー（-1 でタイムチャートの終点の意味）

　　　　＋２.Ｌ：割り込み処理関数へのポインター


　　　Ｃ言語から使用される方は、XSP2lib.H 内で XSP_TIME_CHART という名前で

　　　タイムチャート構造体の型が宣言されていますので、活用して下さい。

　　　　タイムチャートの内容は先頭から読み取られ、逐次ラスター割り込みの設

　　　定がされます。ラスター割り込みがかかるごとに、ユーザー指定の割り込み

　　　処理関数が実行され、そして次のタイムチャートの内容を元に、次のラスター

　　　割り込みが設定されます。割り込みラスターナンバーに -1 が指定されてい

　　　るところまで読み取ったところでタイムチャートの終点と見なされ、ラスター

　　　割り込み処理は終了します。次の帰線期間が来ると、再びタイムチャートの

　　　先頭から読み取りが行なわれます。

　　　　タイムチャートの内容は先頭から読み取られ逐次実行されるので、ラスター

　　　ナンバーの若い割り込み処理順になるようにタイムチャートを記述しなけれ

　　　ばなりません。またタイムチャートの末端には、必ず終点（ラスターナンバー

　　　が -1 ）を記述して下さい。

　　　　なお、割り込みラスターナンバーは、ディスプレイモード３１ＫＨｚ時は

　　　８の倍数、１５ＫＨｚ時は４の倍数で指定して下さい。つまり、Ｙ座標方向

　　　４ドットおきのラスター割り込みしか実現できないことになります。それ以

　　　外のタイミングでのラスター割り込みを指定すると、ＸＳＰシステム側のラ

　　　スター割り込みと衝突し、正常動作しない可能性があります。



--------------------------------------------------------------------------

●　ｘｓｐ＿ｈｓｙｎｃｉｎｔ＿ｏｆｆ

　書式：void  xsp_hsyncint_off() ;

　戻り値：無し


　機能：xsp_hsyncint_on関数により指定された、ユーザー独自のラスター割り込み

　　　処理を解除します。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　複合スプライトの形状データのフォーマットについて

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　複合スプライトの形状データは、最大４０９６パターンまで登録可能です。形状

データは フレームデータ と リファレンスデータ の二つで表されます。フレーム

データは、スプライトの結合のさせ方を表わします。リファレンスデータは、形状

Ｎｏ．別スプライト合成数と、フレームデータの参照開始アドレスを表わします。



●　フレームデータについて

　　フレームデータは、複合スプライトを構成するスプライトを、xobj_set関数等

　で指定された座標を基準にどのような配置で、どのようなスプライトとして表示

　するか、を表わすデータを構造体の配列変数上に羅列したものです。

　　複合スプライトを構成する１個目のスプライトのデータは、xobj_set関数等で

　指定された座標からどれだけズレた位置にそのスプライトを表示するか、という

　相対座標データ "vx,vy" と、スプライトＰＣＧパターンＮｏ. "pt" と、スプラ

　イト反転コード "rv" で表します。２個目のスプライトのデータは、xobj_set関

　数等で指定された座標からではなく、１個目のスプライトからの相対座標データ

　"vx,vy" と、同じく "pt" "rv" で表します。以降同様に、３個目のスプライトの

　データは、２個目のスプライトからの相対座標 "vx,vy" と "pt" "rv" ・・・と

　いうように羅列します。

　　フレームデータ構造体の１要素あたりのフォーマットは以下のようになってい

　ます。

   ┌────── 先頭からのインデクス（バイト数）
   │  ┌──── サイズ（ Ｗ：ワード　Ｌ：ロングワード ）
   │  │    ┌─ 内容
   ↓  ↓    ↓

　＋０.Ｗ：相対座標データ（vx）

　＋２.Ｗ：相対座標データ（vy）

　＋４.Ｗ：スプライトＰＣＧパターンＮｏ.（pt）（0〜0x7FFF）

　＋６.Ｗ：反転コード（rv）　　0x0000：反転せず
 　　　　　　　　　　　　　　　0x4000：左右反転
 　　　　　　　　　　　　　　　0x8000：上下反転
 　　　　　　　　　　　　　　　0xC000：上下左右反転



●　リファレンスデータについて

　　リファレンスデータは、形状Ｎｏ．別スプライト合成数と、フレームデータの

　参照開始アドレスを表わすデータを、構造体の配列変数上に羅列したものです。

　　リファレンスデータ構造体の１要素あたりのフォーマットは以下のようになっ

　ています。

   ┌────── 先頭からのインデクス（バイト数）
   │  ┌──── サイズ（ Ｗ：ワード　Ｌ：ロングワード ）
   │  │    ┌─ 内容
   ↓  ↓    ↓

　＋０.Ｗ：合成スプライト数（num）

　＋２.Ｌ：フレームデータ参照開始アドレス（ptr）

　＋６.Ｗ：未使用（unused）



　形状データは構造体で用意するのが理想的です。フレームデータ用構造体 XOBJ_

FRM_DAT と、リファレンスデータ用構造体 XOBJ_REF_DAT が、XSP2lib.H 内で型宣

言されているので活用して下さい。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　　　その他の注意事項

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


●　処理速度優先のため、厳重なエラーチェックなどはしていません。よって、で

　たらめなスプライトＰＣＧパターンＮｏ．を指定したり、各種初期化を怠ったり

　した場合の動作の保証はありません。注意して下さい。


●　表示画面サイズ７６８×５１２ドットモードの際は、スプライト表示をしない

　ようにすることで、とりあえずバスエラー発生は回避してますが、ＰＣＧ定義が

　不可能になるため、ＰＣＧ管理に破綻をきたすことがあります。よって、ＸＳＰ

　システム組み込み中は、なるべく７６８×５１２ドットモードにしないで下さい。


●　スプライト表示数増加のため、正確なタイミングでラスター割り込みをかける

　必要があります。よって、他で優先度の高い割り込みが使用されていると割り込

　み衝突を起こしスプライト表示に支障を来します。音源ドライバーやＰＣＭ多重

　化ドライバーと併用する場合は要注意です。

　　Ｚ−ＭＵＳＩＣを使用する場合は、Ｚ−ＭＵＳＩＣ常駐時にスイッチに -M を

　指定することで、これを回避できます。ＭＣＤＲＶの場合は、特にスイッチの指

　定等をしなくても、衝突せず動作します（さすがゲーム向けという肩書きを持つ

　だけのことはありますね）。

　　ＰＣＭ８Ａと併用する場合は、垂直帰線期間割り込みが衝突します。これにつ

　いては衝突を回避するよう、ＰＣＭ８Ａ側の割り込みマスク設定にパッチを当て

　る関数（pcm8a_vsyncint_on／off関数）を別途用意してありますので、それを利

　用して下さい。なおＰＣＭ８の場合は、残念ながら同居不可能です。


●　当然ですが、割り込み解除をせずにプログラムを終了すると確実に暴走します。

　プログラム終了前に必ず xsp_off関数で割り込みを解除して下さい。（インタラ

　プトスイッチやコピーキーを使って実行中止をする癖のある人は注意しましょう。）


●　ディスプレイ１５Ｋｈｚ／３１Ｋｈｚ時以外には対応していません。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　スプライト座標の固定小数点の指定方法について

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　XSPsys.s ４６行目の、

SHIFT	=	0		* 座標 固定少数ビット数

は、スプライト座標の固定小数点ビット数を表しています。xsp_set関数等により指

定された座標は、ここで指定されたビット数分、右シフトされて実際のスプライト

座標として使用されます。デフォルトは０（固定小数点無し）です。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　ＸＳＰシステムの設計指針について

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　ここでは、私がＸＳＰシステムを設計するに当たって目指した方向性について説

明したいと思います。ゲームを作ろうという方々でも特に熟練した方は、恐らくこ

の辺りのことが１番気になるところだろうと思いますし、また誤解があってはなら

ないので、以下の内容については十分に理解していただきたいと思います。そういっ

たことは気にしないという方は、読み飛ばしていただいても結構です。


●　対象ユーザーについて

　　　既存のsp_set関数の機能に限界を感じている方を対象ユーザーとして想定し

　　ています。よってsp_set関数から移行しやすいように、xsp_set関数等の引数構

　　成は、sp_set関数を強く意識した作りとなっています。


●　記述性と自由度を重視

　　　記述性や自由度を犠牲にすると、代償として完成するゲームのクオリティー

　　は下がります。高速化に固執した結果、記述性や自由度を損ねるような仕様の

　　システムになってしまっては本末転倒です。プログラムスタイルを強要するよ

　　うな仕様も極力避けました。

　　　速けりゃ何でもいいというのであれば、高速化と称し、ユーザーに用意「さ

　　せた」スプライトバッファをリンク構造で「がんじがらめ」にするような手法

　　もあり得るのです。しかしそのような類いの仕様を導入することは、ユーザー

　　にシステム側の勝手な都合を押しつけることとなり、上記の指針に反すること

　　は言うまでもありません。


●　速度面を重視

　　　可能な限りの高速化の術を尽くしました。


●　対象とするソフトについて

　　　私がＸＳＰシステムと平行して作っていたのが２Ｄシューティングゲームだっ

　　たということもあり、ＸＳＰシステムは２Ｄシューティングゲーム向けの仕様

　　となっています。

　　　まず優先度が６４段階しかないので３Ｄ物に応用するには役不足です。また

　　バッファに登録したスプライトはそのフレーム中１回きりしか表示されないの

　　で、固定位置に表示し続けたいスプライトでもフレーム毎に登録しなければな

　　らないなどの手間が生じます。

　　　速度面でも、複合スプライトよりも単体のスプライトを重視した仕様となっ

　　ています。つまり、細かいキャラクターが大量に出現することを想定しており、

　　２Ｄシューティングゲーム向けの仕様と言えます。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　内部仕様についての詳しい話

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


●　スプライト表示について

　　　xsp_set関数、xobj_set関数などによりＸＳＰシステム内部バッファに登録

　　されたスプライト表示情報は、xsp_out関数により優先度別及びＹ座標別にソー

　　ティングされ、別の保存用バッファに保存されます。この保存用バッファに保

　　存されたスプライト表示情報は、順に垂直帰線期間が来るごとに、スプライト

　　ＲＡＭに転送され、表示されます。

　　　保存用バッファは、表示用・書換用・予備用の合計３本用意してあり、ロー

　　テーションさせて使用しています。バッファを３本用意することにより、垂直

　　同期を無視したバッファローテーションが可能となっています。また３本の保

　　存用バッファはちょっとした緩衝作用を示してくれます。ユーザープログラム

　　が同期を無視したタイミングで動作しても、画面に表示する段階でタイミング

　　調整可能なので、次のＶＳＹＮＣ内で行うべき処理を先行処理できたりする訳

　　です。逆に垂直同期に間に合わなくても、垂直同期を無視したバッファローテー

　　ションが可能なので、次の垂直帰線期間までウェイトをかける必要もありませ

　　ん（つまりスロー現象が目立たなくなる）。この緩衝作用のおかげで、ものに

　　よっては処理が劇的に軽くなったりします。但し xsp_vsync関数による同期を

　　行わない場合は、以上のような緩衝作用は得られないので、注意して下さい。


●　スプライトのラスター分割ソーティングについて

　　　単純にＹ座標別に分けてソーティングし、ラスター割り込みをかけてブロッ

　　ク転送するだけでは、書き換えているところがバレてしまいます。走査線が通

　　過している位置にあるスプライトをさわると、どうしてもちらついたりノイズ

　　が表示されてしまうためです。これを回避するために、１２８枚のスプライト

　　を偶数ナンバーのグループと奇数ナンバーのグループに分け、片方のグループ

　　が表示されている間にもう一方を書き換えるという手法を用いています。


●　ラスター分割位置での優先度破綻を軽減する処理について。

　　　隣り合うラスター分割ブロック間のスプライトの上下関係を、同一の優先度

　　を持つスプライトの集団単位で調節する方法により、優先度破綻の軽減を実現

　　しています。しかし、１ラスターブロック内に使用できるスプライト数は６４

　　枚までなので、優先度破綻を解消し切れない場合が発生してきます。そのよう

　　な場合は仕方がないので、優先度破綻したまま表示するようにしています。


●　ＰＣＧ定義管理アルゴリズムについて

　　　すべてのスプライトＰＣＧパターンに対して、ＰＣＧエリア上のどこに定義

　　されているかを表す配置管理テーブルを用意し、これに基づいてスプライトＰ

　　ＣＧパターンＮｏ．→　ＰＣＧエリアＮｏ．の変換を行っています。テーブル

　　がＰＣＧエリア０番を指しているパターンは、未定義であることを表していま

　　す。よってＰＣＧエリア０番はＸＳＰシステムでは使用しません（もったいな

　　いですが、ＰＣＧエリア０番は大抵ＢＧパーツの定義用に使用するので、この

　　仕様でも特に問題ないと判断しました）。

　　　xsp_out関数内で、優先度別ソーティングを行いつつ、全ＰＣＧエリア（０〜

　　２５５番）別の使用しているか否かのフラグリスト（ソース中の OX_tbl ）を

　　作成しています。同時に、未定義パターンを使用しようとしているスプライト

　　を発見した場合、そのスプライトのバッファ上アドレスを保存しておきます。

　　未定義パターンは、全ＰＣＧエリア別の使用しているか否かのフラグリストが

　　完成してから、フラグリストから未使用ＰＣＧエリアを検索して定義します。

　　　新たにパターンを定義するための未使用ＰＣＧエリアを捜し出すときは注意

　　が必要です。垂直表示期間中にＰＣＧ定義を行う場合は、現在表示に使用して

　　いるＰＣＧエリアを書き換えることはできません。また今回の表示に使用予定

　　のＰＣＧエリアも書き換えることはできません。また１ＶＳＹＮＣ先行処理し

　　ている場合は、予備用バッファのスプライトで使用しているＰＣＧエリアも書

　　き換えることはできません。以上のような事情から、垂直表示期間中に新たに

　　パターンを定義できるＰＣＧエリアは、表示用・書換用・予備用の合計３本の

　　保存バッファにおいて未使用であるＰＣＧエリアに限られます。つまり、過去

　　３ターン連続で未使用だったＰＣＧエリアに限られるわけです（逆に一度定義

　　されたパターンは、最低３ターンの寿命があると考えることができます。この

　　ことはＰＣＧ定義時のキャッシュ効果ＵＰに貢献すると考えられます）。ＸＳ

　　ＰシステムはＰＣＧ定義要求が発生すると、まず過去３ターン連続で未使用の

　　ＰＣＧエリアを捜し出し、垂直帰線期間を待たずＰＣＧ定義を実行します。さ

　　らに、もしここで過去３ターン連続で未使用のＰＣＧエリアが一切見つからな

　　かった場合は（そこで諦めてしまうのはもったいないので）現在表示用として

　　使用中のＰＣＧエリアさえも定義対象とします。但しこの場合、表示中のもの

　　を書き換えることになるため、定義は垂直帰線期間中に行う必要があります。

　　よって、あまり多く書き換えている時間がないので、垂直帰線期間中のＰＣＧ

　　定義は１回につき３１ＰＣＧまでとなっています。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　　　　　　最後に

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　同人ソフト「超連射６８Ｋ」の開発と平行して、ＸＳＰシステムにちょこちょこ

と改良を加えていたのですが、気が付けばソースは跡形もなく新陳代謝され、困っ

たことに仕様までもが新陳代謝されてしまっていました。ＶＥＲ．１．ｘｘからの

ユーザーの方々、大幅変更してしまって申し訳ありません。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　お世話になった ツール ＆ 書籍 ＆ 参考にさせてもらったもの

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　VANISHシステム 　　　　　　　　　　　ゆーり氏作
　HAS　　　　　　　　　　　　　　　　　Y.Nakamura氏作
　HLK　　　　　　　　　　　　　　　　　SALT氏作
　ED.R     　　　　　　　　　　　　　　S.Ueda氏作
　Inside X68000　　　　　　　　　　　　桑野雅彦氏著
　68000プログラマーズハンドブック　　　宍倉幸則氏著




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　　　　　変更履歴

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


ＶＥＲ．１．００：（１９９４／８）

　　●　最大３８４枚までしか表示されなかったバージョン。その後、果てしない
　　　　高速化への道を歩むことになる。


　　　（ＶＥＲ．１．００〜２．００までの過程については省略）


ＶＥＲ．２．００：（１９９６／８）

　　●　機能を大幅に 拡張・強化・洗練 したバージョン。


ＶＥＲ．２．００ 第２改訂版：（１９９７／９）

　　●　本バージョンより、いままで別途配布していた複合スプライト形状データ
　　　　生成ツール CVOBJ.X を梱包。

　　●　サンプルプログラムをＣharlie版ＧＣＣに対応するように修正。また、サ
　　　　ンプルプログラムを追加。ＸＳＰのライブラリ自体には手を加えていない。

　　●　PCG90.s PCM8Afnc.s 周りのバージョンアップ。




□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□

　　　　　　　　　　　　　　配布規定＆連絡先

□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□


　著作権は作者である私が保持しますが、使用・配布は自由です。Ｑ２系ネット以

外なら転載も自由に行って頂いて結構です。常識の範囲内でなら改造等も自由です。

ＸＳＰまたはその一部の、フリーソフト、ディスクマガジン、同人ソフト、及び市

販ソフト等への組み込みに関しても制限はありません。その際、特に報告もいりま

せんし、使用料なども要求しません。但し、そのソフトに梱包されるドキュメント

などにその旨（使用したこと）を記して頂きたいと思います。

　なお、ＸＳＰ（またはその一部）を使用したことにより発生したいかなるトラブ

ルについて、私は一切責任を負いませんので、御了承下さい。


　御意見、御感想、バグ報告、質問などがありましたら、以下のところまで御連絡

下さい。


     Fina tear Z network (06- 719-9206)  ID=0946        ファミベのよっしん
     満開ネット          (03-3985-6227)  ID=0148        ファミベのよっしん



（ＥＯＦ）
