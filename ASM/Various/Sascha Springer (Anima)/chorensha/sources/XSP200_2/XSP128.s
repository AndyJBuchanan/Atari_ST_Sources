*■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■
*
*	１２８枚モード・ソーティングルーチン
*
*■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■□■

					* a0.l = 書換用バッファ管理構造体
	movea.l	div_buff(a0),a1		* a1.l = #ラスター分割バッファＡ

					*---------------------------------------
					* d0.l = 
					* d1.l = 
					* d2.w = 
					* d3.w = 
					* d4.w = 
					* d5.w = 
					* d6.l = 
					* d7.w = 連鎖数 dbccカウンター
					*---------------------------------------
					* a0.l = 仮バッファスキャン ＆ チェインスキャン
					* a1.l = 転送先スキャン
					* a2.l = 
					* a3.l = 
					* a4.l = 
					* a5.l = 
					* a6.l = 
					* a7.l = チェイン先頭情報
					*---------------------------------------

	move.l	(a7)+,a0		* ＰＲごとの先頭アドレス
	move.w	CHAIN_OFS(a0),d7	* 連鎖数（そのままdbccカウンターとして使える）
	bmi.b	SORT_128_END		* いきなり連鎖数が負（終点）なら終了

*-------[ ソーティング処理ループ ]
SORT_128_LOOP_:
	asr.w	#1,d7
	bcc.b	@F

SORT_128_LOOP:
	move.l	(a0)+,(a1)+		* x,y 転送
	move.l	(a0)+,(a1)+		* cd,pr 転送
@@:
	move.l	(a0)+,(a1)+		* x,y 転送
	move.l	(a0)+,(a1)+		* cd,pr 転送
	dbra	d7,SORT_128_LOOP

	movea.l	CHAIN_OFS-4(a0),a0	* 次のＰＲ鎖アドレス
	move.w	CHAIN_OFS(a0),d7	* 連鎖数（そのままdbccカウンターとして使える）
	bpl.b	SORT_128_LOOP_		* 連鎖数≧０なら続行

	*-------[ ＰＲ変更 ]
		move.l	(a7)+,a0		* 次のＰＲの先頭アドレス
		move.w	CHAIN_OFS(a0),d7	* 連鎖数（そのままdbccカウンターとして使える）
		bpl.b	SORT_128_LOOP_		* 連鎖数≧０なら続行

SORT_128_END:


*◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆
*
*	最大１２８枚モード ソート後処理
*
*◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆

	move.l	write_struct(pc),a0		* a0.l = 書換用バッファ管理構造体
	suba.l	div_buff(a0),a1			* a1.l = 使用スプライト数＊８
	move.w	a1,d0
	move.w	d0,buff_sp_total(a0)		* バッファナンバー別 スプライト数＊８ 改めて保存




